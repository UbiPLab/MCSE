DE coordination; asynchronous task-oriented design; continuation monad;
   C++11; domain-specific languages; functional programming
ID THREADS
AB There is a big class of problems that requires writing programs in an asynchronous manner. Cloud computing, service-oriented architectures, multi-core and heterogeneous systems all require programs to be written with asynchronous components. The necessity of concurrency and asynchronous execution brings in the added complexity of the inversion of control into the system, either through message passing or through event processing. In this paper, we introduce explicit programming language support for asynchronous programming that completely hides inversion of control. The presented programming model defines a common abstraction of the different types of tasks, both synchronous and asynchronous. It defines common imperative control constructs equivalent to those of the host programming language, along with a few more advanced ones for transactional and parallel execution that can universally work for any task type. It allows the programmer to implement the logic of an asynchronous system in a natural way by writing simple, seemingly, synchronous imperative code. We will show that the programs written using this approach are easier to understand by programmers. They are also easier to design automated tests for, and for performing computer-based static analysis of the program logic. The principles behind this approach were tested in a couple of real-world systems with worldwide user base. Our experience shows that it makes the complex code with a lot of interdependencies between asynchronously executed tasks easy to write and reason about. Copyright (c) 2016 John Wiley & Sons, Ltd.